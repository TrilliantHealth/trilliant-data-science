link:../README.adoc[â†‘]

= Advanced Memoization

The default approach for `MemoizingPicklingRunner` is _strongly_ preferable, since it
dramatically reduces the possible scope for hidden impurity and therefore receiving
incorrect cached results.

`MemoizingPicklingRunner` transfers your wrapped computation context to a remote
environment, which means that memoization happens correctly and by default. Since the arguments to your
wrapped computation are converted directly into a memoization key, there's no work left for you to do.

Nevertheless, there are some cases where it may be impractical to refactor your code such that the
computation being memoized is relatively pure. In those cases, the `MemoizingPicklingRunner` now provides
some advanced facilities for lying to yourself and the system about the true memoization key for your
computation.

== Configure: pipeline memospace with dynamic runtime matching

[sidebar]
Scope: match a function or set of functions based on their fully-qualified `+__module__:__name__+`
using Python code registered as one of many in-order globally-registered handlers

NOTE: This approach has been largely superseded by the link:pipeline-ids.adoc[affordances]
from `pure.magic.pipeline_id('new-id', mask=True)`. Instead of matching by regex, you can
mask by module tree.

This is probably most appropriate for applications that wish to provide control over the pipeline id or
overall pipeline memospace for their functions but only their functions; in other words, for applications
that do _not_ wish to override the choices of other libraries using mops from which they consume outputs.

A simple example would be something like the following:

[source,python]
----
# in module `thds.bar.where.ever`

@pure.use_runner(...)
def thing1(...):
    """pipeline-id: BAR-STANDARD"""
    ...

# in module `thds.foo.stuff`
@pure.use_runner(...)
def thing2(...):
    """pipeline-id: FOO-STANDARD"""
    ...

# in module `thds.foo.main`
pure.add_pipeline_memospace_handlers(
    pure.matching_mask_pipeline_id('FOO-NON-STANDARD!!', r'thds\.foo')
)
----

The above will mask the pipeline id for `thing2` in `thds.foo.stuff` (as well as any other functions
underneath `thds.foo`) but will _not_ mask the pipeline id for `thds.bar.where.ever:thing1`, as its
fully-qualified name will not match the `thds.foo` regex.

NOTE: This _overrides_ the use of `pipeline_id_mask` in all respects if a match is found. It is up to the
application developers to have their handler respect existing ``pipeline_id_mask``s if they so choose.

== Configure: function-scoped fully-qualified memospace

[sidebar]
Scope: per-function (referenced by function_id) memospace, set by application via global (TOML) or
stack-local (context manager) config.

WARNING: Everything in from this point downward in this document is probably a bad idea
and should only be used if you're desperate to 'retrieve' a memoized result that you know
exists, and you simply can't afford to change your `mops` configuration the standard way
(or recompute).

The most direct option is to configure, on a per-memoized/decorated function basis, the fully-qualified
`memospace` from the known run, referenced by the fully-qualified name of the function at its _current
location_.

NOTE: This approach overrides **both** of the previous approaches, and differs from them in that any
globally-configured blob root will be overridden by this fully-qualified function memospace.

You might use this option if the function in question has been renamed and/or moved to a different module
since the results were memoized, or if you know an exact location where previous results exist and you
want to hard-code that result set outside of your code. This renaming ability affords the most direct
control compared to the other options for configuring memoization.

In the following example, function `foo` was run previously with `pipeline_id=2023april`, and the results
were stored on `adls://thdsdata/ml-ops`. The run which will re-use these results will have an
autogenerated `pipeline_id` and will use the configured values for SA and container for all of the other,
not-configured functions.

In a mops link:./config.adoc[config file], add the following lines to your config:

[source,toml]
----
[mops.memo."thds.mymodule.foomod:foobar"]
memospace = "adls://thdsdata/ml-ops/mops/pipeline-pickled-functions-v1/2023april/thds.mymodule.OLDMOD:barbaz"
----

Note that the name that is part of the configuration key must be the fully-qualified path to the function
in the _current_ codebase. This is how we will recognize what results you're trying to retrieve when you
call the current function.

The `memospace`, however, is a fully-qualified ADLS URI that actually exists and was created by the
previous run that you're trying to reuse. Note that to find this, you need to know three core components
from the previous run:

1. The URI that was configured as `mops.pure.magic.blob_root`.
1. The `pipeline_id` that was in use.
1. The fully qualified `module:function_name@function-logic-key` at the time of the run.

[WARNING]
====
This configuration needs to be present every time a memoized result is retrieved. You cannot perform
a new run with this config, and then expect a future reuse of the _new_ pipeline id to present you with
those results. They will not be found.

In other words, this configuration is cumulative and explicit - if you want to pick up results from
various different historical runs, you'll need to specify the configuration for each previous run.
====

[[keyed-local-runner]]
== `KeyedLocalRunner`

1. The `KeyedLocalRunner` requires that you specify a Blob Storage Root, just like the standard
   `MemoizingPicklingRunner`.

WARNING: The KeyedLocalRunner is local-only! It cannot transfer execution to an actual remote execution
environment, precisely because it will not have the ability to transfer all of your function arguments
to that remote.

2. The second required argument is a `keyfunc` function, to which the original computation
   `(c, args, kwargs)` will be passed immediately prior to constructing the memoization key. Its purpose
   is to return a modified tuple of those `(c, args, kwargs)` footnote:[Why do you need to return the callable? Because we build the memo key off your function name, but _you_ might want to substitute in
a different name for the memo key than the actual wrapped computation has. But in most cases you probably
will just return the callable directly without modifying it.]footnote:[Why do we pass it to your keyfunc in the first
place? You actually don't need to receive the callable or pass it back if you don't want to. If your
keyfunc's first argument is not named `c`, we will not pass you the callable at all, and we'll assume you
didn't want its name in the memo key to change. Instead, we'll splat `args` and `kwargs` into your
keyfunc.] that will be used to construct the
   memoization key - usually you'll still want the modified tuple to be derived from the originals, but
   it's ultimately up to you what sort of dark sorcery you want to perform. A standard approach might be
   to rewrite all arguments as keyword arguments but leave out certain keyword arguments that represent
   unpickleable resources.

NOTE: The returned `(c, args, kwargs)` tuple will NOT be used when finally executing a computation that has
no pre-existing memoized result. The original wrapped computation will be called directly with the
original arguments and keyword arguments.

An example of this working end-to-end can be link:../examples/impure.py[found here].

### nil_args

Drop certain arguments from the memo key. This is the simplest possible case. If you need something
fancier, you may want to look at how `nil_args` is implemented and use some of the utilities provided to
write your own keyfunc-creator.

[source,python]
----
from thds.adls.defaults import mops_root
from thds.mops import pure, impure

@pure.use_runner(impure.KeyedLocalRunner(mops_root, keyfunc=impure.nil_args('conn')))
def run_limit_query_with_database_client(
    conn: sqlite3.Connection, tbl_name: str, limit: int = 3
) -> list:
    # the connection has no bearing on our pure function, so we can
    # use KeyedLocalRunner and `impure.nil_args` to memoize these results
    # without making alternative arrangements for the connection.
    return conn.execute(f"select * from {tbl_name} limit ?", (limit,)).fetchall()
----

### fully custom memo key generation

Write a function that matches the `pure.core.memo.keyfunc.Keyfunc` type, and pass that as the keyfunc.
Note that the returned arguments MUST be bindable to the returned function using
`inspect.signature(func).bind`. You may have to get clever with how you do this if you're trying to bind
a _changed_ set of arguments rather than just dropping values for some of them. The returned function
will not actually get called, so feel free to get as creative as you need.
