link:../README.adoc[â†‘]

# Optimizations

Because transferring execution to a link:./remote.adoc[remote] runtime involves
link:./serialization.adoc[serialization], there can be a performance penalty to using `mops`, compared to running everything locally in shared memory.

Therefore, `mops` has added some optimizations to help avoid compute resource bottlenecks, particularly
on the link:./orchestrator.adoc[orchestrator] process.

## File transfer via Source

****
ðŸ“¢ **Use `thds.core.source.Source` for all file-based inputs and outputs.**

See link:./source.adoc[Source documentation] for complete details, including:

* How to create and use Source objects
* Recommended output patterns (prefer `.out/` directories over temp files)
* Anti-patterns to avoid (context-managed temp files that get deleted)
* How automatic URI assignment works
****

`Source` dramatically reduces peak memory pressure on the orchestrator process by streaming data from/to disk rather than holding it in memory. It also preserves the "droppability" of `mops` â€” your code works identically with or without `mops`.

### pathlib.Path (deprecated)

See link:./paths.adoc[paths] for documentation on this still-supported but less well optimized functionality.

## Non-file large shared objects

**(Upload a large object once per pipeline)**

For large non-file objects being passed many times as read-only parameters to functions, you may reduce
serialization and upload resource usage by identifying those objects as 'shared'.

Under the hood, this defers serialization until the time of upload based on the object's ID. Objects that
are 'shared' must be both pickleable and weak referenceable; noisy errors will occur if they are not.
Pandas DataFrames and Numpy NDArrays will work out of the box. Python ``list``s will not, though
subclassing can wrap them to make them weak-referenceable. Consult the Python
link:https://docs.python.org/3.8/library/weakref.html[`weakref` docs] for more details.

This is a feature of the `MemoizingPicklingRunner`, and usage will look something like this:

[source,python]
----
runner = MemoizingPicklingRunner(...)

def your_orchestrator(...):
    ...
    runner.shared(training_x_df, y=training_y_ndarr)

    ...
    the_remote_df_func(training_x_df, training_y_ndarr, ...)


@use_runner(runner)
def the_remote_df_func(x_df, y_ndarr, ...):
    ...
----

If passed as a keyword parameter, the name serves only for debugging purposes - otherwise it is
meaningless and there is no risk of collision.
