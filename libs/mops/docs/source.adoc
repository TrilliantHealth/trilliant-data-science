link:../README.adoc[↑]

# Source: File-based Inputs and Outputs

`thds.core.source.Source` is the recommended abstraction for passing file-based data into and out of `mops`-decorated functions. It provides significant optimizations over raw `pathlib.Path` and preserves the "droppability" of `mops` — your code should work identically whether `mops` is enabled or not.

## Why Source?

On a basic level, `Source` represents two conceptually different possibilities for data availability:

- available on the local filesystem
- available remotely, but able to be downloaded to the local filesystem when opened for reading

By using this abstraction, functions can obey
link:https://en.wikipedia.org/wiki/Robustness_principle[Postel's law] and take advantage of the
link:https://en.wikipedia.org/wiki/Liskov_substitution_principle[Liskov substitution principle]: your function code does not need to change depending on where the data is coming from (local file or remote URI), and callers have maximum control over where they source data and what they receive.

## Creating Sources

`Source` objects should be created via:

- `thds.core.source.from_file(path)` — for local files
- `thds.core.source.from_uri(uri)` — for remote data (e.g., `adls://...`)
- `thds.adls.source.from_adls(fqn)` — if you have an `AdlsFqn`

`Source` is `os.PathLike`, so `open(source)` works directly — calling `open()` or `source.path()` triggers download if the data isn't already local.

## Returning Source from a Function

****
Write output files to a persistent subdirectory of cwd (conventionally `.out/`), then return `from_file(path)`. `mops` handles the rest.
****

[source,python]
----
from pathlib import Path
from thds.core.source import Source, from_file

def remote_func(src_a: Source, src_b: Source) -> Source:
    outf = Path.cwd() / '.out' / 'c.txt'
    outf.parent.mkdir(parents=True, exist_ok=True)
    with open(outf, 'w') as wf:
        wf.write(open(src_a).read() + '\n' + open(src_b).read())
    return from_file(outf)


def orchestrator():
    src_a = from_file('a.txt')
    src_b = from_file(Path('b.txt'))  # works with Path, too
    src_c = remote_func(src_a, src_b)
    assert open(src_c).read() == open(src_a).read() + '\n' + src_b.path().read_text()
----

This code works whether or not `mops` is in play. If your function runs remotely, `mops` automatically assigns a remote URI (derived from the invocation output URI + the file's relative path, stripping `.out/`) and uploads the file. If you run locally, the file just exists at `.out/c.txt`.

See `apps/k8s-mops-demo` for a runnable end-to-end example of these patterns.

=== Why `.out/` instead of temp directories?

**Droppability**: A file at `./.out/my_result.parquet` is immediately usable by any downstream consumer. A file in `/var/tmp/xyz123/` disappears when the temp context closes.

**Clean URIs**: `mops` derives URIs from the relative path, so `.out/reports/snow.txt` becomes something like `adls://ds/tmp/pipeline/my_func/.../reports/snow.txt`. Predictable URIs make debugging easier.

**Reproducibility**: Persistent output directories let you inspect intermediate outputs and compare runs without re-executing.

NOTE: Files under cwd can share basenames if they have different relative paths (e.g., `./a/result.parquet` and `./b/result.parquet`). Files outside cwd fall back to basename-only naming and must have unique basenames.

## Controlling the Output URI

=== Controlling the path suffix

Your `.out/` subpath is preserved as the _suffix_ of the auto-assigned URI — e.g. `.out/snapshots/my_snapshot.parquet` becomes `adls://.../<mops-memo-path>/snapshots/my_snapshot.parquet`. This gives you a meaningful filename and directory structure, but the output always lives _within_ the mops memo namespace. Without mops, the file just stays at `.out/snapshots/my_snapshot.parquet` locally.

If that's sufficient, prefer plain `from_file` — it's the simplest and most droppable option.

=== Specifying an explicit URI

If you need the output at a _specific absolute_ URI outside the mops memo namespace (e.g. a well-known ADLS path that other systems read from), use the `uri` parameter:

[source,python]
----
return from_file(output_path, uri="adls://ds/prod-datasets/snapshots/snapshot.parquet")
----

This tells mops where to put the file, but **does not upload immediately** — mops handles the upload during result serialization. Your code still runs in a local context, but the URI is now hardcoded, so you lose the automatic root adaptation described above.

=== Escape hatch: `create_source_at_uri`

[source,python]
----
from thds.mops.pure import create_source_at_uri

src = create_source_at_uri(local_path, "adls://my-sa/container/explicit/path.txt")
----

This is equivalent to `from_file(path, uri=...)` plus an immediate upload. Use it only when the upload _must_ happen inside the function — for instance, in a live web application where the local file is ephemeral and won't survive past the request. If you use this pattern, add a comment explaining why immediate upload is necessary.

WARNING: Manual upload forces every invocation to hit ADLS, eliminating the possibility of a local-only test run. It also risks name collisions, including overwriting data meant to be read-only for a downstream process.

## Anti-patterns

=== Context-managed temporary files

[source,python]
----
# !! ANTIPATTERN - DO NOT DO THIS !!
@pure.magic()
@scope.bound  # <-- this is the problem
def make_a_file() -> Source:
    tmp_file = scope.enter(tmp.temppath_same_fs())
    with open(tmp_file, "w") as f:
        f.write("hello!")
    return from_file(tmp_file)  # File will be DELETED before mops can upload!
----

`@scope.bound` (or any cleanup context manager) exits when your function returns — _before_ mops can upload the file. The Source points to a deleted file.

=== When you really need temp files

Use `mops.tempdir()`, which persists until the interpreter exits:

[source,python]
----
from thds.mops import tempdir

@pure.magic()
def make_a_file() -> Source:
    output = tempdir() / "my_output.txt"
    with open(output, "w") as f:
        f.write("hello!")
    return from_file(output)
----

This works, but your code won't produce local output without `mops`. Prefer `.out/` when possible.

## Technical Notes

- `source.uri` for a locally-created file will be a `file://` URI (or a hook-assigned remote URI within a mops invocation context)
- `source.uri` for a remote-only file will be the remote URI (`adls://...`)
- The current implementation does not support efficient byte-range seeking — the entire file must be downloaded before access

## Related Documentation

- link:./paths.adoc[Non-optimized Path handling (deprecated)]
- link:./optimizations.adoc[Other optimizations (large shared objects)]
