link:../README.adoc[↑]

# Concepts

This document explains the execution model underlying `mops` — how your code runs on
remote environments, and what you need to set up for that to work.

## execution environment

`thds.mops` must be installed both in the local environment and the remote environment.

On the link:orchestrator.adoc[orchestrator], you will need to install the dependencies
required for importing your function. If your function can be imported and the arguments
to it constructed, `mops` will kick in and prevent the function itself from being called
on the local machine.  A common pattern is to defer environment-specific imports (such as
`pyspark`) to the inside of the function. You might want to split the bulk of the function into a separate module,
and import that module within the `+mops+`-wrapped function, e.g.:

[source,python]
----
@pure.magic()
def foobar(*args, **kwargs):
    from . import internal

    return internal.foobar(*args, **kwargs)
----
NOTE: The above is an abbreviated example; we do not recommend using `*args, **kwargs`,
which lowers code readability.

On the link:remote.adoc[remote(s)], you will need to install `mops` and all dependencies
required for importing the function as well as executing it.

In practice, the simplest way to do this will often be to package the entire Python
application and install it on the remote,footnote:[Often, a good way to do this will be to
have a single Docker image or wheel that contains the full application and is used
for/installed on both the orchestrator and the remote(s).] even though only a part of
it will actually be executed.


## Transfer of control to the remote via a runtime shim

To run your function remotely, you need to choose a link:./shims.adoc[runtime shim]
implementation and environment. The best choice will often be Python running in a Docker
container spawned by link:kubernetes.adoc[Kubernetes], but as demonstrated by
link:quickstart.adoc[the quickstart], it is also possible to use something as simple as
running in the same thread (the default for `@pure.magic()`).

[source,python]
----
import typing as ty

from thds.mops import pure, k8s

IMAGE_TAG: ty.Final = "docker.io/myimage:latest"
MOPS_ROOT_URI: ty.Final = "adls://yoursa/container/"

run_on_k8s = k8s.shim(
    IMAGE_TAG,
    node_narrowing=dict(resource_requests=dict(memory='120G'))
)

@pure.magic(run_on_k8s, blob_root=MOPS_ROOT_URI)
def my_resource_intensive_function(model: pd.DataFrame, rounds: int) -> pd.DataFrame:
    ... # do some stuff, return a dataframe

if __name__ == '__main__':
    # now, call your function locally and it will be run remotely
    df = my_resource_intensive_function(the_model_df, 15)
    assert type(df) == pd.DataFrame
    # `df` is your result, computed on and transferred back from the remote context
----

Now you run your application locally, and your functions will be called remotely and their results will
be returned to you. Your local process can call `@pure.magic`-decorated functions in threads or even
separate processes, though threads are your best bet for the large majority of scenarios.

## File I/O with Source

For passing files into and out of `mops` functions, use link:source.adoc[`Source`] objects.
`Source` provides efficient, transparent file transfer between local and remote environments,
with automatic deduplication and lazy downloading.

## Bypassing mops

To run a `@pure.magic()`-decorated function without mops (no memoization, no remote execution),
use link:magic.adoc#off[`pure.magic.off()`] or set `mops.pure.magic.shim = "off"` in your
`.mops.toml` config file.
