"""Utilities built around pickle for the purpose of transferring large amounts of on-disk data and also functions."""
import importlib
import inspect
import io
import pickle
import typing as ty

from thds.core.log import getLogger

from .types import Args, Kwargs

logger = getLogger(__name__)


class PicklableFunction:
    """The main 'issue' this is working around is that decorated
    functions aren't picklable because of something having to do with
    the way the function gets 'replaced' at decoration time.

    There may be other solutions to this, but this seems to work fine.
    """

    def __init__(self, f):
        if f.__module__ == "__main__":
            raise ValueError(
                f"Cannot pickle function {f} that is in the __main__ module"
                " because it will not be able to be found in a different process with a different __main__."
                " Please move it to a different module."
            )
        self.fmod = f.__module__
        self.fname = f.__name__
        self.f = None

    def __str__(self) -> str:
        return f"{self.fmod}.{self.fname}"

    def __call__(self, *args, **kwargs):
        logger.debug(f"Dynamically importing function {str(self)}")
        mod = importlib.import_module(self.fmod)
        self.f = getattr(mod, self.fname)
        return self.f(*args, **kwargs)


def wrap_f(f):
    if hasattr(f, "__module__") and hasattr(f, "__name__"):
        return PicklableFunction(f)
    return f


T = ty.TypeVar("T")
Deserializer = ty.Callable[[], T]
Serializer = ty.Callable[[T], Deserializer]
PickleHandler = ty.Callable[[T], ty.Union[None, Deserializer]]
# returns None if the object should be pickled normally.
# Otherwise returns a picklable Callable that will itself return the unpickled object when called.


class _CallbackPickler(pickle.Pickler):
    def __init__(self, handlers: ty.Sequence[PickleHandler], *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.handlers = handlers

    def persistent_id(self, obj):
        for handler in self.handlers:
            pid = handler(obj)
            if pid is not None:
                return pid
        return None


class CallableUnpickler(pickle.Unpickler):
    """Present same interface as pickle.load but support unpickling callable PIDs generated by CallbackPickler."""

    def persistent_load(self, pid):
        try:
            return pid()
        except TypeError as te:
            # logger.exception("TypeError hit while debugging")
            # this line should never get hit as long as nobody asks us to unpickle PIDs we don't know about
            raise pickle.UnpicklingError(f"unsupported persistent object - {te}")  # pragma: no cover


class Dumper:
    """Presents the same interface as pickle.dump but supports
    arbitrary callback-based unpickling.
    """

    def __init__(self, handlers: ty.Sequence[PickleHandler]):
        self.handlers = handlers

    def __call__(self, obj: object, file: ty.IO, *args, **kwargs):
        _CallbackPickler(self.handlers, file, *args, **kwargs).dump(obj)


def gimme_bytes(pickle_dump: ty.Callable[[object, ty.IO], None], obj: object) -> bytes:
    with io.BytesIO() as bio:
        pickle_dump(obj, bio)
        bio.seek(0)
        return bio.read()


def freeze_args_kwargs(dumper: Dumper, f, args: Args, kwargs: Kwargs) -> bytes:
    """Returns a pickled (args, kwargs) tuple, with pre-bound
    arguments to normalize different call structures into a
    canonical/determinstic binding.

    Also binds default arguments, for maximum determinism/explicitness.
    """
    bound_arguments = inspect.signature(f).bind(*args, **kwargs)
    bound_arguments.apply_defaults()
    return gimme_bytes(dumper, (bound_arguments.args, bound_arguments.kwargs))


def unfreeze_args_kwargs(args_kwargs_pickle: bytes) -> ty.Tuple[Args, Kwargs]:
    """Undoes a freeze_args_kwargs call."""
    return CallableUnpickler(io.BytesIO(args_kwargs_pickle)).load()
