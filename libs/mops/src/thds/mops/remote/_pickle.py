"""Utilities built around pickle for the purpose of transferring large amounts of on-disk data and also functions."""
import importlib
import io
import pickle
import typing as ty

from thds.core.log import getLogger

logger = getLogger(__name__)


class PicklableFunction:
    """The main 'issue' this is working around is that decorated
    functions aren't picklable because of something having to do with
    the way the function gets 'replaced' at decoration time.

    There may be other solutions to this, but this seems to work fine.
    """

    def __init__(self, f):
        self.fmod = f.__module__
        self.fname = f.__name__
        self.f = None

    def __call__(self, *args, **kwargs):
        logger.info(f"Dynamically importing function {self.fname} from module {self.fmod}")
        mod = importlib.import_module(self.fmod)
        self.f = getattr(mod, self.fname)
        return self.f(*args, **kwargs)


def wrap_f(f):
    if hasattr(f, "__module__") and hasattr(f, "__name__"):
        return PicklableFunction(f)
    return f


T = ty.TypeVar("T")
Deserializer = ty.Callable[[], T]
Serializer = ty.Callable[[T], Deserializer]
PickleHandler = ty.Callable[[T], ty.Union[None, Deserializer]]
# returns None if the object should be pickled normally.
# Otherwise returns a picklable Callable that will itself return the unpickled object when called.


class _CallbackPickler(pickle.Pickler):
    def __init__(self, handlers: ty.Sequence[PickleHandler], *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.handlers = handlers

    def persistent_id(self, obj):
        for handler in self.handlers:
            pid = handler(obj)
            if pid is not None:
                return pid
        return None


class CallableUnpickler(pickle.Unpickler):
    """Present same interface as pickle.load but support unpickling callable PIDs generated by CallbackPickler."""

    def persistent_load(self, pid):
        try:
            return pid()
        except TypeError:
            pass
        # this line should never get hit as long as nobody asks us to unpickle PIDs we don't know about
        raise pickle.UnpicklingError("unsupported persistent object")  # pragma: no cover


class Dumper:
    """Presents the same interface as pickle.dump but supports pickling paths."""

    def __init__(self, handlers: ty.Sequence[PickleHandler]):
        self.handlers = handlers

    def __call__(self, obj: object, file: ty.IO, *args, **kwargs):
        _CallbackPickler(self.handlers, file, *args, **kwargs).dump(obj)


def gimme_bytes(pickle_dump: ty.Callable[[object, ty.IO], None], obj: object) -> bytes:
    with io.BytesIO() as bio:
        pickle_dump(obj, bio)
        bio.seek(0)
        return bio.read()
