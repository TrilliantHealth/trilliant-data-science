"""Utilities built around pickle for the purpose of transferring large amounts of on-disk data and also functions."""
import inspect
import io
import pickle
import typing as ty

# so we can pickle and re-raise exceptions with remote tracebacks
from tblib import pickling_support  # type: ignore

from thds.core.log import getLogger

from ..core.types import Args, Kwargs, SerializerHandler, T
from ..core.uris import get_bytes
from .pickles import PicklableFunction

logger = getLogger(__name__)


def wrap_f(f):
    if hasattr(f, "__module__") and hasattr(f, "__name__"):
        return PicklableFunction(f)
    return f


class _CallbackPickler(pickle.Pickler):
    def __init__(self, handlers: ty.Sequence[SerializerHandler], *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.handlers = handlers

    def persistent_id(self, obj):
        if isinstance(obj, Exception):
            pickling_support.install(obj)
        for handler in self.handlers:
            pid = handler(obj)
            if pid is not None:
                return pid
        return None


class CallableUnpickler(pickle.Unpickler):
    """Present same interface as pickle.load but support unpickling callable PIDs generated by CallbackPickler."""

    def persistent_load(self, pid):
        try:
            return pid()
        except TypeError as te:
            # logger.exception("TypeError hit while debugging")
            # this line should never get hit as long as nobody asks us to unpickle PIDs we don't know about
            raise pickle.UnpicklingError(f"unsupported persistent object - {te}")  # pragma: no cover


class Dumper:
    """Presents the same interface as pickle.dump but supports
    arbitrary callback-based unpickling.
    """

    def __init__(self, *handlers: SerializerHandler):
        self.handlers = handlers

    def __call__(self, obj: object, file: ty.IO, *args, **kwargs):
        _CallbackPickler(self.handlers, file, *args, **kwargs).dump(obj)


def gimme_bytes(pickle_dump: ty.Callable[[object, ty.IO], None], obj: object) -> bytes:
    with io.BytesIO() as bio:
        pickle_dump(obj, bio)
        bio.seek(0)
        return bio.read()


def make_read_object(
    type_hint: str, wrapper: ty.Callable[[ty.Any], T] = lambda o: o
) -> ty.Callable[[str], T]:
    def read_object(uri: str) -> T:
        return wrapper(CallableUnpickler(io.BytesIO(get_bytes(uri, type_hint=type_hint))).load())

    return read_object


def freeze_args_kwargs(dumper: Dumper, f, args: Args, kwargs: Kwargs) -> bytes:
    """Returns a pickled (args, kwargs) tuple, with pre-bound
    arguments to normalize different call structures into a
    canonical/determinstic binding.

    Also binds default arguments, for maximum determinism/explicitness.
    """
    bound_arguments = inspect.signature(f).bind(*args, **kwargs)
    bound_arguments.apply_defaults()
    return gimme_bytes(dumper, (bound_arguments.args, bound_arguments.kwargs))


def unfreeze_args_kwargs(args_kwargs_pickle: bytes) -> ty.Tuple[Args, Kwargs]:
    """Undoes a freeze_args_kwargs call."""
    return CallableUnpickler(io.BytesIO(args_kwargs_pickle)).load()
